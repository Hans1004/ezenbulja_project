<html lang="ko" layout:decorate="~{layout/layout}" xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout">
    <div class="container" layout:fragment="content">
        <h1>딥러닝 번호 추천</h1>
        <hr>

        <div class="row justify-content-center mb-4">
            <div class="col-md-4 g-1">
                <input type="file" accept=".csv" onchange="loadCSVFile(event)" class="btn btn-primary w-100"/>
            </div>
            <div class="col-md-4 g-1">
                <input id="predictButton" class="btn btn-primary btn-lg w-100" type="button" value="딥러닝 번호 추천">
            </div>
            <div class="col-md-4 g-1">
                <a href="check_numbers.html" class="btn btn-primary btn-lg w-100">내번호 당첨확인</a>
            </div>
        </div>

        <div class="radio-buttons">
            <h2>분석할 기간 선택</h2>
            <label class="me-3"><input type="radio" name="period" value="all" checked> 전체</label>
            <label class="me-3"><input type="radio" name="period" value="12"> 최근 1년</label>
            <label class="me-3"><input type="radio" name="period" value="24"> 최근 2년</label>
            <label><input type="radio" name="period" value="36"> 최근 3년</label>
        </div>
        <div id="result">
            <h2></h2>
        </div>
        <div class="row">
            <div class="col-lg-6 col-sm-12">
                <canvas id="lossChart"></canvas>
            </div>
            <div class="col-lg-6 col-sm-12">
                <canvas id="accuracyChart"></canvas>
            </div>
        </div>

        <div class="row">
            <div class="col-lg-6 col-sm-12">
                <canvas id="frequencyChart"></canvas>
            </div>  
            <div class="col-lg-6 col-sm-12">
                <canvas id="predictionChart"></canvas>
            </div>
        </div>

        <div id="result"></div>
    </div>

    <script>
        let lossChart, accuracyChart, frequencyChart, predictionChart;
        let parsedData = []; // 전역 변수로 데이터 저장
        let currentModel; // 현재 모델 저장

        // CSV 파일 로드 및 파싱 함수
        function loadCSVFile(event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = function(event) {
                const data = event.target.result;
                parsedData = parseCSV(data);
                setupCharts();  // 차트 초기화
                // 라디오 버튼 선택 상태에 따라 데이터 필터링 및 모델 학습
                applyPeriodFilter();
            };
            reader.readAsText(file);
        }

        // CSV 데이터를 배열로 변환
        function parseCSV(data) {
            const rows = data.split('\n');
            const result = [];
            for (let i = 1; i < rows.length; i++) { // 첫 행은 헤더이므로 제외
                const values = rows[i].split(',');
                if (values.length >= 7) {
                    // 데이터에 회차 정보가 있다고 가정하고, 첫 번째 열이 회차라고 가정합니다.
                    result.push(values.slice(1, 7).map(Number));
                }
            }
            return result;
        }

        // 기간 필터링 함수
        function applyPeriodFilter() {
            const period = document.querySelector('input[name="period"]:checked').value;
            let filteredData = [];

            if (period === 'all') {
                filteredData = parsedData;
            } else {
                const numMonths = parseInt(period);
                const totalDraws = parsedData.length;
                const drawsPerMonth = 4; // 월별 평균 추첨 수 (주 1회 추첨 시)
                const numDraws = numMonths * drawsPerMonth;

                // 최근 데이터부터 선택
                filteredData = parsedData.slice(-numDraws);
            }

            // 모델 재훈련 및 예측
            trainAndPredict(filteredData);

            // 빈도 차트 업데이트
            const frequency = calculateFrequency(filteredData);
            updateFrequencyChart(frequency);
        }

        // 라디오 버튼 이벤트 리스너 추가
        document.querySelectorAll('input[name="period"]').forEach(radio => {
            radio.addEventListener('change', () => {
                if (parsedData.length > 0) {
                    applyPeriodFilter();
                }
            });
        });

        // 모델 학습 및 예측 함수
        async function trainAndPredict(data) {
            if (currentModel) {
                currentModel.dispose();
            }

            const xs = data.slice(0, -1);

            // 타겟 데이터 준비 (원-핫 인코딩)
            const ys = [];
            for (let i = 1; i < data.length; i++) {
                ys.push(data[i].map(num => oneHotEncode(num, 45)).flat());
            }

            const inputTensor = tf.tensor2d(xs);
            const outputTensor = tf.tensor2d(ys);

            const model = createModel();
            currentModel = model;

            const earlyStopping = tf.callbacks.earlyStopping({ monitor: 'val_loss', patience: 5 });
            const callbacks = {
                onEpochEnd: (epoch, logs) => updateCharts(epoch, logs),
                earlyStopping
            };

            await model.fit(inputTensor, outputTensor, {
                epochs: 50,
                batchSize: 32,
                validationSplit: 0.2,
                callbacks
            });

            const lastDraw = data[data.length - 1];
            const prediction = model.predict(tf.tensor2d([lastDraw]));
            const predictionArray = await prediction.array();

            let predictedNumbers = [];
            for (let i = 0; i < 6; i++) {
                const groupStart = i * 45;
                const groupEnd = groupStart + 45;
                const group = predictionArray[0].slice(groupStart, groupEnd);
                const maxIndex = group.indexOf(Math.max(...group));
                predictedNumbers.push(maxIndex + 1);
            }

            displayPredictedNumbers(predictedNumbers);

            updatePredictionChart(predictionArray[0]);
        }

        // 딥러닝 모델 생성 함수
        function createModel() {
            const model = tf.sequential();
            model.add(tf.layers.dense({ units: 128, activation: 'relu', inputShape: [6] }));
            model.add(tf.layers.batchNormalization());
            model.add(tf.layers.dense({ units: 64, activation: 'relu' }));
            model.add(tf.layers.dropout({ rate: 0.3 }));
            model.add(tf.layers.dense({ units: 32, activation: 'relu' }));
            model.add(tf.layers.dense({ units: 45 * 6, activation: 'softmax' })); // 수정된 부분

            const optimizer = tf.train.adam(0.001);
            model.compile({
                optimizer: optimizer,
                loss: 'categoricalCrossentropy',
                metrics: ['categoricalAccuracy'] // 수정된 부분
            });

            return model;
        }

        // 차트 설정 함수
        function setupCharts() {
            const lossCtx = document.getElementById('lossChart').getContext('2d');
            const accuracyCtx = document.getElementById('accuracyChart').getContext('2d');
            const frequencyCtx = document.getElementById('frequencyChart').getContext('2d');
            const predictionCtx = document.getElementById('predictionChart').getContext('2d');

            lossChart = new Chart(lossCtx, {
                type: 'line',
                data: { labels: [], datasets: [{ label: 'Loss', borderColor: 'red', data: [], fill: false }] },
                options: { responsive: true }
            });

            accuracyChart = new Chart(accuracyCtx, {
                type: 'line',
                data: { labels: [], datasets: [{ label: 'Accuracy', borderColor: 'blue', data: [], fill: false }] },
                options: { responsive: true }
            });

            frequencyChart = new Chart(frequencyCtx, {
                type: 'bar',
                data: {
                    labels: Array.from({ length: 45 }, (_, i) => i + 1),
                    datasets: [{
                        label: 'Number Frequency',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1,
                        data: Array(45).fill(0)
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: 'Number' }},
                        y: { beginAtZero: true, title: { display: true, text: 'Frequency' }}
                    }
                }
            });

            predictionChart = new Chart(predictionCtx, {
                type: 'bar',
                data: {
                    labels: Array.from({ length: 45 }, (_, i) => i + 1),
                    datasets: [{
                        label: 'Prediction Probability',
                        backgroundColor: 'rgba(153, 102, 255, 0.2)',
                        borderColor: 'rgba(153, 102, 255, 1)',
                        borderWidth: 1,
                        data: Array(45).fill(0)
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: { title: { display: true, text: 'Number' }},
                        y: { beginAtZero: true, title: { display: true, text: 'Probability' }}
                    }
                }
            });
        }

        // 학습 과정 시각화 함수
        function updateCharts(epoch, logs) {
            console.log('Epoch ' + (epoch + 1) + ' logs:', logs);

            lossChart.data.labels.push(epoch + 1);
            lossChart.data.datasets[0].data.push(logs.loss);
            lossChart.update();

            accuracyChart.data.labels.push(epoch + 1);
            const accuracy = logs.categoricalAccuracy || logs.acc || logs.accuracy;
            if (accuracy !== undefined) {
                accuracyChart.data.datasets[0].data.push(accuracy);
            } else {
                accuracyChart.data.datasets[0].data.push(null);
            }
            accuracyChart.update();
        }

        // 출현 빈도 차트를 업데이트하는 함수
        function updateFrequencyChart(frequency) {
            frequencyChart.data.datasets[0].data = frequency;
            frequencyChart.update();
        }

        // 예측 분포 차트를 업데이트하는 함수
        function updatePredictionChart(predictionArray) {
            // 각 번호의 예측 확률을 합산
            const summedProbabilities = Array(45).fill(0);
            for (let i = 0; i < 6; i++) {
                const groupStart = i * 45;
                const groupEnd = groupStart + 45;
                const group = predictionArray.slice(groupStart, groupEnd);
                for (let j = 0; j < 45; j++) {
                    summedProbabilities[j] += group[j];
                }
            }
            // 확률 정규화
            const total = summedProbabilities.reduce((a, b) => a + b, 0);
            const normalizedProbabilities = summedProbabilities.map(p => p / total);

            predictionChart.data.datasets[0].data = normalizedProbabilities;
            predictionChart.update();
        }

        // 출현 빈도 계산 함수
        function calculateFrequency(data) {
            const frequency = Array(45).fill(0);
            data.forEach(row => {
                row.forEach(number => {
                    frequency[number - 1]++;
                });
            });
            return frequency;
        }

        // 원-핫 인코딩 함수
        function oneHotEncode(value, numClasses) {
            const oneHot = new Array(numClasses).fill(0);
            oneHot[value - 1] = 1;
            return oneHot;
        }

        // 예측 번호 출력 함수
        function displayPredictedNumbers(numbers) {
            // 번호를 정렬
            numbers.sort((a, b) => a - b);
            
            const resultDiv = document.getElementById("result");
            
            // 이전 결과를 지우기 위해 innerHTML 초기화
            resultDiv.innerHTML = "";

            numbers.forEach(num => {
                const ball = document.createElement('div');
                ball.className = 'lotto-number ' + getColorClass(num);
                ball.textContent = num;
                resultDiv.appendChild(ball);
            });

            // 번호를 로컬 스토리지에 저장
            saveNumbersToLocal(numbers);
        }

        // 번호를 로컬 스토리지에 저장하는 함수
        function saveNumbersToLocal(numbers) {
        const savedNumbers = JSON.parse(localStorage.getItem('savedNumbers')) || [];

        // 현재 날짜와 시간을 함께 저장
        const now = new Date();
        const dateString = now.toISOString(); // 날짜를 ISO 문자열로 저장
        savedNumbers.push({ date: dateString, numbers: numbers });
        localStorage.setItem('savedNumbers', JSON.stringify(savedNumbers));
        }

        // 번호 색상 결정 함수
        function getColorClass(number) {
            if (number >= 1 && number <= 10) return 'yellow';
            if (number >= 11 && number <= 20) return 'blue';
            if (number >= 21 && number <= 30) return 'red';
            if (number >= 31 && number <= 40) return 'gray';
            if (number >= 41 && number <= 45) return 'green';
            return '';
        }

        // "딥러닝 번호 추천" 버튼 클릭 시 이벤트
        document.getElementById('predictButton').addEventListener('click', () => {
            if (parsedData.length > 0) {
                applyPeriodFilter();
            } else {
                alert('먼저 CSV 파일을 로드해주세요.');
            }
        });

    </script>
</html>
